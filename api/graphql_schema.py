import strawberry
from typing import List, Optional, Any, Dict, AsyncGenerator
from strawberry.types import Info
from loguru import logger
import asyncio
from collections import defaultdict

from routes import (
    get_intent_logic,
    get_insight_logic,
    get_topic_logic,
    get_recommendation_logic
)

# Progress tracking storage
progress_storage: Dict[str, List[Dict[str, Any]]] = defaultdict(list)
progress_subscribers: Dict[str, List[asyncio.Queue]] = defaultdict(list)

# Text streaming storage
text_stream_subscribers: Dict[str, List[asyncio.Queue]] = defaultdict(list)


# 1. DEFINE GRAPHQL DATA TYPES

# A flexible scalar type for raw query rows (dictionary-like structures)
DataRow = strawberry.scalar(
    Any,
    name="DataRow",
    description="A flexible dictionary type representing a single row of raw query data."
)


@strawberry.type
class Chart:
    """Represents a Plotly chart generated as part of an insight."""
    chart: Optional[str] = strawberry.field(description="The Plotly chart represented as a JSON string.")
    chart_type: Optional[str] = strawberry.field(description="The type of chart produced (e.g., 'trend').")
    chart_library: Optional[str] = strawberry.field(description="The charting library used to generate the chart (e.g., 'plotly').")


@strawberry.type
class Intent:
    """Represents the detected user intent regarding desired output components."""
    wants_text: bool
    wants_chart: bool
    wants_table: bool
    wants_simplified_numbers: bool


@strawberry.input
class IntentInput:
    """GraphQL input type for passing recognized intent."""
    wants_text: bool
    wants_chart: bool
    wants_table: bool
    wants_simplified_numbers: bool


@strawberry.type
class InsightResponse:
    """Full response returned for an insight query, which may include text, charts, and raw data."""
    output: Optional[str] = strawberry.field(description="The natural language insight generated by the LLM.")
    chart: Optional[Chart] = strawberry.field(description="Chart details if visualization was generated.")
    data_columns: Optional[List[str]] = strawberry.field(description="The list of column names in the raw data table.")
    data_rows: Optional[List[DataRow]] = strawberry.field(description="The raw query result rows.")  # type: ignore
    intent: Optional[Intent] = strawberry.field(description="The recognized intent used for generating this response.")


@strawberry.type
class TopicResponse:
    """Response object for topic generation requests."""
    output: str = strawberry.field(description="The generated conversation topic.")


@strawberry.type
class RecommendationResponse:
    """Response object for recommendation generation requests."""
    output: str = strawberry.field(description="The generated recommendation or follow-up question.")


@strawberry.type
class ProgressUpdate:
    """Real-time progress update from backend processing."""
    request_id: str
    step: str
    status: str  # 'in_progress', 'completed', 'error'
    message: str
    timestamp: str
    details: Optional[str] = None


@strawberry.type
class InsightStreamChunk:
    """Streaming chunk of insight text."""
    request_id: str
    chunk: str
    is_final: bool = False


# Helper functions for progress tracking
def emit_progress(request_id: str, step: str, status: str, message: str, details: Optional[str] = None):
    """Emit progress update to all subscribers for this request_id."""
    from datetime import datetime
    
    update = {
        "request_id": request_id,
        "step": step,
        "status": status,
        "message": message,
        "timestamp": datetime.now().isoformat(),
        "details": details
    }
    
    # Store in history
    progress_storage[request_id].append(update)
    
    # Notify subscribers
    if request_id in progress_subscribers:
        for queue in progress_subscribers[request_id]:
            try:
                queue.put_nowait(update)
            except asyncio.QueueFull:
                logger.warning(f"Queue full for request {request_id}, skipping update")


def clear_progress(request_id: str):
    """Clear progress history for a request."""
    if request_id in progress_storage:
        del progress_storage[request_id]
    if request_id in progress_subscribers:
        del progress_subscribers[request_id]


def emit_text_stream(request_id: str, chunk: str, is_final: bool = False):
    """Emit streaming text chunk to all subscribers for this request_id."""
    if request_id in text_stream_subscribers:
        for queue in text_stream_subscribers[request_id]:
            try:
                queue.put_nowait({"chunk": chunk, "is_final": is_final})
            except asyncio.QueueFull:
                logger.warning(f"Text stream queue full for request {request_id}, skipping chunk")


# 2. DEFINE THE MAIN QUERY & RESOLVERS

@strawberry.type
class Query:
    @strawberry.field
    async def get_insight(self, info: Info, query: str, request_id: str, chat_history: Optional[str] = None) -> InsightResponse:
        """
        Resolver for generating insights with progress tracking.
        The intent is now fully handled within this backend logic.
        """
        logger.info(f"GraphQL get_insight called with query: '{query}' and request_id: '{request_id}'")
        
        emit_progress(request_id, "init", "in_progress", "Memulai pemrosesan permintaan...")

        try:
            
            # 1. Inspect requested fields
            requested_fields = {field.name for field in info.selected_fields[0].selections}
            logger.info(f"Requested fields: {requested_fields}")

            emit_progress(request_id, "processing", "in_progress", "Memproses insight dengan agentic workflow...")

            # 2. Run the main agentic logic
            result_dict = await get_insight_logic(
                query=query,
                chat_history=chat_history,
                requested_fields=list(requested_fields),
                request_id=request_id
            )

            # 3. Wrap chart data
            chart_obj: Optional[Chart] = None
            if result_dict.get("chart"):
                emit_progress(request_id, "chart", "completed", "Grafik berhasil dibuat")
                chart_obj = Chart(
                    chart=result_dict.get("chart"),
                    chart_type=result_dict.get("chart_type"),
                    chart_library=result_dict.get("chart_library")
                )
            
            intent_dict = result_dict.get("intent")
            intent_obj: Optional[Intent] = None

            if isinstance(intent_dict, dict):
                intent_obj = Intent(**intent_dict)

            emit_progress(request_id, "complete", "completed", "Pemrosesan selesai!")
            
            return InsightResponse(
                output=result_dict.get("output"),
                chart=chart_obj,
                data_columns=result_dict.get("data_columns"),
                data_rows=result_dict.get("data_rows"),
                intent=intent_obj
            )
        except Exception as e:
            emit_progress(request_id, "error", "error", f"Terjadi kesalahan: {str(e)}")
            logger.error(f"Error in get_insight: {e}")
            raise
    
    @strawberry.field
    async def recognize_intent(self, query: str) -> Intent:
        """Resolver that uses LLM logic to detect the userâ€™s intent for text, chart, table, or simplified numbers."""
        intent_dict = await get_intent_logic(query)
        return Intent(**intent_dict)
    
    @strawberry.field
    async def get_topic(self, chat_history: str) -> TopicResponse:
        """Resolver that generates a conversational topic from chat history."""
        topic_text = await get_topic_logic(chat_history)
        return TopicResponse(output=topic_text)

    @strawberry.field
    async def get_recommendation(self, chat_history: str) -> RecommendationResponse:
        """Resolver that generates a recommendation or follow-up question from chat history."""
        rec_text = await get_recommendation_logic(chat_history)
        return RecommendationResponse(output=rec_text)


@strawberry.type
class Subscription:
    """GraphQL Subscription for real-time progress updates."""
    
    @strawberry.subscription
    async def progress_updates(self, request_id: str) -> AsyncGenerator[ProgressUpdate, None]:
        """
        Subscribe to real-time progress updates for a specific request.
        
        Usage:
        subscription {
            progressUpdates(requestId: "unique-request-id") {
                requestId
                step
                status
                message
                timestamp
                details
            }
        }
        """
        logger.info(f"Client subscribed to progress updates for request_id: {request_id}")
        
        # Create a queue for this subscriber
        queue: asyncio.Queue = asyncio.Queue(maxsize=100)
        
        # Register this subscriber
        if request_id not in progress_subscribers:
            progress_subscribers[request_id] = []
        progress_subscribers[request_id].append(queue)
        
        try:
            # Send any existing progress updates first
            if request_id in progress_storage:
                for update in progress_storage[request_id]:
                    yield ProgressUpdate(**update)
            
            # Then stream new updates
            while True:
                update = await queue.get()
                yield ProgressUpdate(**update)
                
                # If this is the final update, clean up
                if update["status"] in ("completed", "error") and update["step"] in ("complete", "error"):
                    break
                    
        except asyncio.CancelledError:
            logger.info(f"Subscription cancelled for request_id: {request_id}")
        finally:
            if request_id in progress_subscribers:
                try:
                    progress_subscribers[request_id].remove(queue)
                    if not progress_subscribers[request_id]:
                        del progress_subscribers[request_id]
                except ValueError:
                    pass
            logger.info(f"Client unsubscribed from progress updates for request_id: {request_id}")
    
    @strawberry.subscription
    async def insight_stream(self, request_id: str) -> AsyncGenerator[InsightStreamChunk, None]:
        """
        Subscribe to real-time streaming of insight text.
        
        Usage:
        subscription {
            insightStream(requestId: "unique-request-id") {
                requestId
                chunk
                isFinal
            }
        }
        """
        logger.info(f"Client subscribed to insight stream for request_id: {request_id}")
        
        # Create a queue for this subscriber
        queue: asyncio.Queue = asyncio.Queue(maxsize=1000)
        
        # Register this subscriber
        if request_id not in text_stream_subscribers:
            text_stream_subscribers[request_id] = []
        text_stream_subscribers[request_id].append(queue)
        
        try:
            while True:
                chunk_data = await queue.get()
                yield InsightStreamChunk(
                    request_id=request_id,
                    chunk=chunk_data["chunk"],
                    is_final=chunk_data.get("is_final", False)
                )
                
                # If this is the final chunk, clean up
                if chunk_data.get("is_final", False):
                    break
                    
        except asyncio.CancelledError:
            logger.info(f"Insight stream subscription cancelled for request_id: {request_id}")
        finally:
            # Clean up: remove this subscriber
            if request_id in text_stream_subscribers:
                try:
                    text_stream_subscribers[request_id].remove(queue)
                    if not text_stream_subscribers[request_id]:
                        del text_stream_subscribers[request_id]
                except ValueError:
                    pass
            logger.info(f"Client unsubscribed from insight stream for request_id: {request_id}")


# 3. CREATE THE FINAL SCHEMA

schema = strawberry.Schema(query=Query, subscription=Subscription)